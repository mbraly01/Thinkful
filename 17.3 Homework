import pandas as pd
import numpy as np
from sqlalchemy import create_engine
import warnings

warnings.filterwarnings('ignore')
#1. Determine all the variable types and find the fraction of the missing
#values for each variable
postgres_user = 'dsbc_student'
postgres_pw = '7*.8G9QH21'
postgres_host = '142.93.121.174'
postgres_port = '5432'
postgres_db = 'useducation'

engine = create_engine('postgresql://{}:{}@{}:{}/{}'.format(
    postgres_user, postgres_pw, postgres_host, postgres_port, postgres_db))

useducation_df = pd.read_sql_query('select * from useducation', con=engine)

useducation_df.info()

#2.Notice that the data has a time dimension (year). For this assignment,
#forget about time and treat all the observations as if they're from the
#same year. Choose a strategy to deal with the missing values for each
#variables. For which variables would filling in the missing values with
#some value make sense? For which might tossing out the records entirely
#make sense?


#For revenue we can use imputation, selecting a mean or median of
#the different revnue types. Same for expenditure. This is because
#these values are continous, not categorical
'''
useducation_df["TOTAL_REVENUE"].fillna(useducation_df["TOTAL_REVENUE"].mean(), inplace=True)
useducation_df["TOTAL_EXPENDITURE"].fillna(useducation_df["TOTAL_EXPENDITURE"].mean(), inplace=True)
'''

#for categorical variables, like grades, they are all ordinal so
#we can replace the null value with the value nearest to it
#same goes for the math score.
'''
for i in range(0, len(useducation_df["GRADES_PK_G"])):
    if useducation_df["GRADES_PK_G"][i] == 0:
        useducation_df["GRADES_PK_G"][i] = useducation_df["GRADES_PK_G"][i-1]
'''
#3. Now, take into account the time factor. Replicate your second answer but
#this time fill in the missing values by using a statistic that is calculated
#within the year of the observation. For example, if you want to fill a
#missing value for a variable with the mean of that variable, calculate
#the mean by using only the observations for that specific year

years_list = useducation_df["TOTAL_REVENUE"].groupby(useducation_df["YEAR"]).mean()

#4. Use interpolation instead (Trouble with interpolation error
#No axis named 1 for object type


for i in range(0, len(useducation_df["TOTAL_REVENUE"])):
    if useducation_df["TOTAL_REVENUE"][i] == 0 or np.isnan(useducation_df["TOTAL_REVENUE"][i]):
        print("success 2")
        useducation_df["TOTAL_REVENUE"][i] = useducation_df["TOTAL_REVENUE"].interpolate('linear',1)
print(useducation_df["TOTAL_REVENUE"])

#Compare your results for the 2nd, 3rd, and 4th questions. Do you find
#any meaningful differences?
